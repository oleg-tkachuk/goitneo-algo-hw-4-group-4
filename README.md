# goitneo-algo-hw-4-group-4

## Час виконання алгоритмів:
- **Insertion Sort:**
  - 100 елементів: 0.000094083 с
  - 1000 елементів: 0.011882958 с
  - 10000 елементів: 1.273967209 с
- **Merge Sort:**
  - 100 елементів: 0.000082125 с
  - 1000 елементів: 0.001011375 с
  - 10000 елементів: 0.013231750 с
- **Timsort (використання `sorted`):**
  - 100 елементів: 0.000007958 с
  - 1000 елементів: 0.000085417 с
  - 10000 елементів: 0.001024750 с

## Аналіз результатів:
1. **Insertion Sort:** Цей алгоритм має значне збільшення часу виконання зі зростанням розміру масиву. Це відображає його теоретичну складність O(n²), що робить його менш ефективним на великих масивах.
2. **Merge Sort:** Ефективність цього алгоритму значно вища, особливо на великих масивах. Його теоретична складність O(n log n) пояснює більш лінійне зростання часу виконання зі збільшенням розміру масиву.
3. **Timsort:** Цей алгоритм показує найкращі результати за всіх розмірів масивів. Надзвичайно малий час виконання, навіть на великих масивах, вказує на його високу ефективність. Timsort є гібридним алгоритмом, який оптимізує виконання, адаптуючись до різних типів вхідних даних, що робить його ідеальним вибором для вбудованих алгоритмів сортування у мовах програмування, таких як Python.

## Висновки:
З цих даних випливає, що Timsort значно перевершує як Insertion Sort, так і Merge Sort за часом виконання на всіх розмірах масивів. Це підтверджує вибір Timsort як стандартного алгоритму сортування у Python та вказує на його перевагу у реальних застосуваннях.
